/**
 * TypeScript型定義の自動生成
 * イベントマッピングとAPIマッピングからTypeScript型定義を生成
 */

import { eventMappings } from './mappings/events';
import { apiMappings } from './mappings/apis';
import type { EventMapping, ApiMapping } from './types';

export interface TypeGeneratorOptions {
  includeExamples?: boolean;
  includeDocumentation?: boolean;
  outputFormat?: 'typescript' | 'dts';
  namespace?: string;
}

export class TypeGenerator {
  private options: TypeGeneratorOptions;

  constructor(options: TypeGeneratorOptions = {}) {
    this.options = {
      includeExamples: true,
      includeDocumentation: true,
      outputFormat: 'typescript',
      namespace: 'KtnBridge',
      ...options
    };
  }

  /**
   * 全ての型定義を生成
   */
  public generateAllTypes(): string {
    const parts = [];

    // ヘッダー
    parts.push(this.generateHeader());

    // 基本型定義
    parts.push(this.generateBaseTypes());

    // イベント型定義
    parts.push(this.generateEventTypes());

    // API型定義
    parts.push(this.generateApiTypes());

    // ヘルパー型定義
    parts.push(this.generateHelperTypes());

    // 名前空間で囲む
    if (this.options.namespace) {
      return this.wrapInNamespace(parts.join('\n\n'));
    }

    return parts.join('\n\n');
  }

  /**
   * イベント型定義のみを生成
   */
  public generateEventTypes(): string {
    const parts = [];

    if (this.options.includeDocumentation) {
      parts.push('/**');
      parts.push(' * kintone イベント型定義');
      parts.push(' * Web標準のイベントからkintoneイベントへのマッピング');
      parts.push(' */');
    }

    // イベントタイプの列挙
    const eventTypes = Object.keys(eventMappings).map(key => `'${key}'`).join(' | ');
    parts.push(`export type KintoneEventType = ${eventTypes};`);

    // 各イベントの詳細型定義
    Object.entries(eventMappings).forEach(([eventType, mapping]) => {
      parts.push(this.generateEventTypeDefinition(eventType, mapping));
    });

    // イベントハンドラー型定義
    parts.push(this.generateEventHandlerTypes());

    return parts.join('\n\n');
  }

  /**
   * API型定義のみを生成
   */
  public generateApiTypes(): string {
    const parts = [];

    if (this.options.includeDocumentation) {
      parts.push('/**');
      parts.push(' * kintone API型定義');
      parts.push(' * Web標準のfetch APIからkintone APIへのマッピング');
      parts.push(' */');
    }

    // APIタイプの列挙
    const apiTypes = Object.keys(apiMappings).map(key => `'${key}'`).join(' | ');
    parts.push(`export type KintoneApiType = ${apiTypes};`);

    // 各APIの詳細型定義
    Object.entries(apiMappings).forEach(([apiType, mapping]) => {
      parts.push(this.generateApiTypeDefinition(apiType, mapping));
    });

    return parts.join('\n\n');
  }

  private generateHeader(): string {
    const parts = [];
    parts.push('/**');
    parts.push(' * ktn-bridge TypeScript型定義');
    parts.push(' * 自動生成されたファイル - 直接編集しないでください');
    parts.push(' * Generated by ktn-bridge type generator');
    parts.push(' */');
    return parts.join('\n');
  }

  private generateBaseTypes(): string {
    return `
/**
 * 基本型定義
 */
export interface KintoneFieldValue {
  type: string;
  value: any;
}

export interface KintoneRecord {
  [fieldCode: string]: KintoneFieldValue;
}

export interface KintoneApp {
  appId: string;
  name: string;
  description?: string;
}

export interface KintoneUser {
  code: string;
  name: string;
  email?: string;
}

export interface KintoneSpace {
  id: string;
  name: string;
  isPrivate: boolean;
}`;
  }

  private generateEventTypeDefinition(eventType: string, mapping: EventMapping): string {
    const parts = [];

    if (this.options.includeDocumentation) {
      parts.push('/**');
      parts.push(` * ${mapping.web.description}`);
      parts.push(` * Web event: ${mapping.web.event}`);
      if (mapping.web.selector) {
        parts.push(` * Selector: ${mapping.web.selector}`);
      }
      if (mapping.since) {
        parts.push(` * @since ${mapping.since}`);
      }
      if (mapping.deprecated) {
        parts.push(' * @deprecated');
      }
      parts.push(' */');
    }

    // イベントデータの型定義
    const eventInterfaceName = this.pascalCase(eventType.replace(/\./g, '_')) + 'EventData';
    parts.push(`export interface ${eventInterfaceName} {`);
    parts.push('  type: \'' + eventType + '\';');
    parts.push('  appId?: string;');
    parts.push('  recordId?: string;');
    
    // イベントタイプに応じた固有プロパティ
    if (eventType.includes('index')) {
      parts.push('  records?: KintoneRecord[];');
    } else if (eventType.includes('detail') || eventType.includes('edit') || eventType.includes('create')) {
      parts.push('  record?: KintoneRecord;');
    }
    
    if (eventType.includes('change')) {
      parts.push('  changes?: {');
      parts.push('    field: {');
      parts.push('      type: string;');
      parts.push('      value: any;');
      parts.push('    };');
      parts.push('  };');
      parts.push('  fieldName?: string;');
    }
    
    if (eventType.includes('beforeunload')) {
      parts.push('  hasUnsavedChanges?: boolean;');
    }
    
    if (eventType.includes('bulkEdit')) {
      parts.push('  selectedRecords?: string[];');
      parts.push('  timestamp?: string;');
    }
    
    if (eventType.includes('click')) {
      parts.push('  action?: string;');
      parts.push('  element?: HTMLElement;');
    }
    
    parts.push('}');

    // 使用例（オプション）
    if (this.options.includeExamples) {
      parts.push('');
      parts.push('/**');
      parts.push(' * 使用例:');
      parts.push(' * ```typescript');
      parts.push(mapping.example.web.trim().split('\n').map(line => ' * ' + line).join('\n'));
      parts.push(' * ```');
      parts.push(' */');
    }

    return parts.join('\n');
  }

  private generateApiTypeDefinition(apiType: string, mapping: ApiMapping): string {
    const parts = [];

    if (this.options.includeDocumentation) {
      parts.push('/**');
      parts.push(` * ${mapping.web.description}`);
      parts.push(` * Web method: ${mapping.web.method}`);
      parts.push(' */');
    }

    // API リクエスト型定義
    const requestTypeName = this.pascalCase(apiType.replace(/\./g, '_')) + 'Request';
    parts.push(`export interface ${requestTypeName} {`);
    parts.push('  url: string;');
    parts.push('  method: string;');
    parts.push('  headers?: Record<string, string>;');
    parts.push('  body?: any;');
    parts.push('}');

    // API レスポンス型定義
    const responseTypeName = this.pascalCase(apiType.replace(/\./g, '_')) + 'Response';
    parts.push(`export interface ${responseTypeName} {`);
    parts.push('  data?: any;');
    parts.push('  error?: string;');
    parts.push('  status: number;');
    parts.push('}');

    // 使用例（オプション）
    if (this.options.includeExamples) {
      parts.push('');
      parts.push('/**');
      parts.push(' * 使用例:');
      parts.push(' * ```typescript');
      parts.push(mapping.example.web.trim().split('\n').map(line => ' * ' + line).join('\n'));
      parts.push(' * ```');
      parts.push(' */');
    }

    return parts.join('\n');
  }

  private generateEventHandlerTypes(): string {
    const eventTypes = Object.keys(eventMappings);
    const handlerTypes = eventTypes.map(eventType => {
      const eventInterfaceName = this.pascalCase(eventType.replace(/\./g, '_')) + 'EventData';
      return `  '${eventType}': (event: ${eventInterfaceName}) => void;`;
    }).join('\n');

    return `
/**
 * イベントハンドラー型定義
 */
export interface KintoneEventHandlers {
${handlerTypes}
}

/**
 * イベントハンドラー関数の型
 */
export type KintoneEventHandler<T extends KintoneEventType> = KintoneEventHandlers[T];`;
  }

  private generateHelperTypes(): string {
    return `
/**
 * ヘルパー型定義
 */
export type KintoneEventListener<T extends KintoneEventType> = (
  event: T extends keyof KintoneEventHandlers 
    ? Parameters<KintoneEventHandlers[T]>[0] 
    : never
) => void;

/**
 * フィールドタイプ
 */
export type KintoneFieldType = 
  | 'SINGLE_LINE_TEXT'
  | 'MULTI_LINE_TEXT'
  | 'RICH_TEXT'
  | 'NUMBER'
  | 'DATE'
  | 'DATETIME'
  | 'TIME'
  | 'DROP_DOWN'
  | 'RADIO_BUTTON'
  | 'CHECK_BOX'
  | 'MULTI_SELECT'
  | 'FILE'
  | 'LINK'
  | 'USER_SELECT'
  | 'GROUP_SELECT'
  | 'ORGANIZATION_SELECT'
  | 'STATUS'
  | 'RECORD_NUMBER'
  | 'CREATED_TIME'
  | 'UPDATED_TIME'
  | 'CREATOR'
  | 'MODIFIER'
  | 'SUBTABLE'
  | 'REFERENCE_TABLE';

/**
 * ステータス型
 */
export type KintoneStatus = 
  | '未着手'
  | '進行中'
  | 'レビュー待ち'
  | 'テスト中'
  | '完了'
  | '保留'
  | 'キャンセル';

/**
 * 優先度型
 */
export type KintonePriority = 
  | 'low'
  | 'medium'
  | 'high'
  | 'urgent';`;
  }

  private wrapInNamespace(content: string): string {
    return `declare namespace ${this.options.namespace} {
${content.split('\n').map(line => line ? '  ' + line : '').join('\n')}
}

export = ${this.options.namespace};
export as namespace ${this.options.namespace};`;
  }

  private pascalCase(str: string): string {
    return str.replace(/(?:^|_)([a-z])/g, (_, letter) => letter.toUpperCase());
  }

  /**
   * 型定義ファイルとして出力
   */
  public generateTypeDefinitionFile(): string {
    const content = this.generateAllTypes();
    
    if (this.options.outputFormat === 'dts') {
      return content;
    }
    
    return content;
  }

  /**
   * 特定のイベントタイプの型定義を生成
   */
  public generateEventTypeOnly(eventType: string): string {
    const mapping = eventMappings[eventType];
    if (!mapping) {
      throw new Error(`Event type ${eventType} not found`);
    }
    
    return this.generateEventTypeDefinition(eventType, mapping);
  }

  /**
   * 特定のAPIタイプの型定義を生成
   */
  public generateApiTypeOnly(apiType: string): string {
    const mapping = apiMappings[apiType];
    if (!mapping) {
      throw new Error(`API type ${apiType} not found`);
    }
    
    return this.generateApiTypeDefinition(apiType, mapping);
  }
}

/**
 * 型定義生成の便利関数
 */
export function generateTypes(options?: TypeGeneratorOptions): string {
  const generator = new TypeGenerator(options);
  return generator.generateAllTypes();
}

export function generateEventTypes(options?: TypeGeneratorOptions): string {
  const generator = new TypeGenerator(options);
  return generator.generateEventTypes();
}

export function generateApiTypes(options?: TypeGeneratorOptions): string {
  const generator = new TypeGenerator(options);
  return generator.generateApiTypes();
}

export function generateTypeDefinitionFile(options?: TypeGeneratorOptions): string {
  const generator = new TypeGenerator(options);
  return generator.generateTypeDefinitionFile();
}

export default TypeGenerator;